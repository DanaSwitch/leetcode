# 相交链表

假设有两个链表 A 和 B，它们的长度可能不同，但可能在某一点相交（合并）。

- **链表 A**: `a1 -> a2 -> c1 -> c2` (长度 4)
- **链表 B**: `b1 -> c1 -> c2` (长度 3)
- 相交点是 `c1`。

**问题：** 如果让指针 A 和指针 B 同时出发，因为长度不同，它们到达 `c1` 的时间不同，所以虽然它们会经过同一个节点，但不会**同时**到达，也就无法判断相交。

**解决方案（这行代码的魔力）：**

让指针 A 走完链表 A 之后，立刻去走链表 B；

让指针 B 走完链表 B 之后，立刻去走链表 A。

**逻辑推导：**

- 指针 A 的路线：`走完 A (长度 L_A)` -> `再走 B (长度 L_B)`。总路程 = $L_A + L_B$
- 指针 B 的路线：`走完 B (长度 L_B)` -> `再走 A (长度 L_A)`。总路程 = $L_B + L_A$

因为 $L_A + L_B = L_B + L_A$，所以两个指针**走的总是路程一样长**。

1. 如果有相交节点，它们会在**第二次遍历时，同时到达相交节点**。
2. 如果没有相交节点，它们会同时走到各自路线的终点（也就是同时变成 `None`），循环结束。

### 3. 图解演示

假设：

List A: `[1, 2, 8, 9]`

List B: `[3, 8, 9]`

相交于 `8`。

**执行过程：**

| **步数** | **指针 A (值)** | **指针 B (值)** | **状态**                  |
| -------- | --------------- | --------------- | ------------------------- |
| 1        | 1               | 3               | 不相等                    |
| 2        | 2               | 8               | 不相等                    |
| 3        | 8               | 9               | 不相等                    |
| 4        | 9               | None            | **B 走完了**              |
| 5        | None            | **1 (headA)**   | **A 走完了，B 跳到 A 头** |
| 6        | **3 (headB)**   | 2               | **A 跳到 B 头**           |
| 7        | **8**           | **8**           | **相遇！找到交点**        |

### 4. 这种解法的一个浪漫比喻

程序员圈子里常把这个算法比作**“错的人迟早走散，对的人终会相逢”**：

> “我走过你走过的路（链表 B），你走过我走过的路（链表 A），我们终究会相遇（在交点）。如果我们无缘（不相交），我们最后会在终点（None）通过互相道别而结束。”