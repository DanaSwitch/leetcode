# 滑动窗口
## T3 无重复字符的最长子串

次优解

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s: return 0
        # 用哈希表判断是否村子啊重复字符
        max_len = 0 #最大长度
        tp = [] #放字符串的一个队列
        for a in s:
            # 如果字串中已经存在a了,就删除最左边的,将右边的a添加进来
            while a in tp:
                del tp[0] #删除队列左边第一个,直到没有重复字符串
            tp.append(a)
            # 更新字串最大长度
            if len(tp) > max_len: 
                max_len = len(tp)
        return max_len
```

最优解

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:return 0
        left = 0
        lookup = set()
        n = len(s)
        max_len = 0
        cur_len = 0
        for i in range(n):
            cur_len += 1
            while s[i] in lookup:
                lookup.remove(s[left])
                left += 1
                cur_len -= 1
            if cur_len > max_len:max_len = cur_len
            lookup.add(s[i])
        return max_len
```



这两段代码的**宏观战略（解题思路）是完全一样的**，都是“滑动窗口”。

但是在**战术执行（具体实现方式）上，这段新代码比你之前的代码高明了一个段位**。

如果说你的代码是“小米步枪”，这段新代码就是“半自动步枪”。它们的根本区别在于**“怎么维护窗口”**以及**“怎么查重”**。

------

### 1. 核心区别图解

#### 你的代码（物理搬运）：

你维护了一个真实的列表 `tp`。

- **查重 (`a in tp`)：** 这是一个 List。Python 必须从头遍历到尾去确认有没有重复。如果窗口里有 1 万个字，它就要看 1 万次。**（慢）**
- **出窗 (`del tp[0]`)：** 这是一个“搬砖”操作。删掉第一个，后面所有人都要往前挪一步。**（慢，O(N)）**

#### 新代码（逻辑标记）：

它没有建立一个新的列表来存字符，而是直接在原字符串 `s` 上用两个指针（`left` 和 `i`）画了一个框。辅助用了一个 `set`（集合）。

- **查重 (`s[i] in lookup`)：** `lookup` 是一个 **Set（哈希集合）**。它的特长是“瞬间查找”。不管里面有 1 万个还是 1 亿个数据，它查一下有没有重复只需要 $O(1)$ 的时间。**（极快）**
- **出窗 (`left += 1`)：** 它不需要搬运数据！它只需要把左边的指针往右移一格，顺便在小本本（Set）上把那个字划掉。**（极快，O(1)）**

------

### 2. 逐行对比（看看它怎么优化你的逻辑）

| **步骤**       | **你的思路 (List)**                  | **新代码思路 (Set + Pointer)**         | **为什么新代码更好？**                    |
| -------------- | ------------------------------------ | -------------------------------------- | ----------------------------------------- |
| **存储窗口**   | `tp = []` (新建一个列表)             | `left = 0`, `i` (两个指针夹住原字符串) | 没必要新建一个列表存字符，**省内存**。    |
| **判断重复**   | `while a in tp:` (列表轮询)          | `while s[i] in lookup:` (哈希查找)     | Set 查找是 **O(1)**，List 是 **O(N)**。   |
| **移动左边界** | `del tp[0]` (物理删除，后面全部前移) | `lookup.remove(...)`   `left += 1`     | 只是指针数字 +1，**不需要搬运内存数据**。 |

------

### 3. 时间复杂度大比拼

假设字符串长度是 $N$。

- **你的代码：**
  - 最坏情况下（比如字符串是 "abcdefg..." 没有重复），对于每个字符，你都要在 `tp` 里查一遍。
  - 总耗时 ≈ $O(N^2)$。如果字符串有 10 万个字，你的程序可能会超时。
- **新代码：**
  - 每个字符最多进 Set 一次，出 Set 一次。查找和删除都是 $O(1)$。
  - 总耗时 = $O(N)$。哪怕字符串有一亿个字，它也跑得飞快。