# 最大连续1的个数

```python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        ans = left = cnt0 = 0  # 初始化：最大长度ans，左边界left，窗口内0的个数cnt0
        
        # right 是右边界，x 是当前进入窗口的数值
        for right, x in enumerate(nums): 
            
            # 1. 进窗口逻辑
            # 这里用了一个数学小技巧：
            # 如果 x 是 0，(1 - x) 就是 1 -> cnt0 加 1
            # 如果 x 是 1，(1 - x) 就是 0 -> cnt0 不变
            cnt0 += 1 - x  
            
            # 2. 出窗口逻辑 (当 0 的数量超过 k 时)
            while cnt0 > k:
                # 判断左边移出去的那个数 nums[left] 是不是 0
                # 如果是 0，cnt0 就要减 1；如果是 1，cnt0 不变
                cnt0 -= 1 - nums[left]
                left += 1  # 左边界收缩
            
            # 3. 更新最大长度
            # right - left + 1 就是当前有效窗口的长度
            ans = max(ans, right - left + 1)
            
        return ans
```



## 一. 问答

就是我比较疑惑的是题目不是要求数组中连续 1 的最大个数吗，这个ans不是窗口中最大连续1的个数，窗口外的还没有算

---

这是一个非常棒的疑问！这触及到了滑动窗口算法的**本质**。

你的担心是：“窗口只是数组的一部分，那窗口**外面**（比如之前遍历过的那些 1）岂不是被忽略了？”

**核心答案是：不会被忽略。因为 `ans` 是一个“历史最高分记录板”，而窗口是一个“扫描仪”。**

我们要区分两个概念：

1. **`right - left + 1`**：这是**当前**这一刻，窗口看着的这一小段的长度。
2. **`ans`**：这是**从开始到现在**，我们见过的所有窗口中，最长的那个长度。

### 为什么“窗口外”的不用担心？

我们可以把这个过程看作是在**给数组拍全景照片**：

1. **左边的“外面”**：

   窗口是从左向右滑动的。**窗口左边**那些现在不在窗口里的元素，**其实在之前的循环里已经被窗口“包”住过了**。

   当时如果它们构成的连续 1 很长，那个长度已经被记在 `ans` 里了。即便现在窗口移走了，`ans` 依然记得那个最大值。

2. **右边的“外面”**：

   右边还没遍历到的元素，会在未来的循环步骤中被 `right` 指针吃进来。等窗口滑过去的时候，自然会计算它们。

- 没问题！我们换一个更有代表性的例子，这次 **`k = 2`**（允许翻转 2 个 0）。

  这个例子会完美展示：**即使后来窗口变小了、甚至变“差”了，`ans` 是如何把之前的“巅峰时刻”牢牢记住的。**

  ### 设定场景

  - **数组 `nums`：** `[1, 1, 0, 0, 1, 1, 1, 0, 1]`
  - **`k = 2`** （也就是说，窗口里最多只能容纳 2 个 `0`）

  我们将一步步看 `left`（窗口左边）、`right`（窗口右边）和 `ans`（历史最高记录）是如何变化的。

  ------

  ### 详细推演过程

  #### 第一阶段：贪婪扩张（快乐地吃进 0）

  在这个阶段，`cnt0` 还没有超过 `k`，窗口只管变大。

  | **步骤** | **right 指向的值** | **窗口内容 (left~right)** | **cnt0 (0的个数)** | **状态** | **操作**     | **ans (历史最高)** |
  | -------- | ------------------ | ------------------------- | ------------------ | -------- | ------------ | ------------------ |
  | 1        | `1`                | `[1]`                     | 0                  | OK       | 继续         | 1                  |
  | 2        | `1`                | `[1, 1]`                  | 0                  | OK       | 继续         | 2                  |
  | 3        | `0`                | `[1, 1, 0]`               | 1                  | OK       | 继续         | 3                  |
  | 4        | `0`                | `[1, 1, 0, 0]`            | **2** (达到上限)   | OK       | 继续         | 4                  |
  | 5        | `1`                | `[1, 1, 0, 0, 1]`         | 2                  | OK       | 继续         | 5                  |
  | 6        | `1`                | `[1, 1, 0, 0, 1, 1]`      | 2                  | OK       | 继续         | 6                  |
  | 7        | `1`                | `[1, 1, 0, 0, 1, 1, 1]`   | 2                  | OK       | **记录巅峰** | **7**              |

  > **重点说明：** 到第 7 步时，窗口覆盖了 `[1, 1, 0, 0, 1, 1, 1]`。里面正好有 2 个 `0`，符合规则。长度为 7。此时 **`ans` 更新为 7**。**这是整个数组中最辉煌的时刻。**

  ------

  #### 第二阶段：消化不良（遇到第 3 个 0，被迫收缩）

  现在 `right` 继续往右走，遇到了一个新的 `0`。

  | **步骤** | **right 指向的值** | **原始窗口内容**           | **cnt0** | **状态**  | **left 的动作 (收缩)**                 | **新窗口内容** | **ans** |
  | -------- | ------------------ | -------------------------- | -------- | --------- | -------------------------------------- | -------------- | ------- |
  | 8        | `0`                | `[1, 1, 0, 0, 1, 1, 1, 0]` | **3**    | **超标!** | `left` 必须右移，直到踢出一个 `0` 为止 | ...            | **7**   |

  **详细看第 8 步的 `while` 循环（收缩过程）：**

  1. 目前窗口里有 3 个 `0`。`left` 在下标 0 (值是 `1`)。
     - 踢出 `nums[0]`(1)。`cnt0` 还是 3。`left` 变成 1。
  2. `cnt0` 还是 3，继续循环。`left` 在下标 1 (值是 `1`)。
     - 踢出 `nums[1]`(1)。`cnt0` 还是 3。`left` 变成 2。
  3. `cnt0` 还是 3，继续循环。`left` 在下标 2 (值是 **`0`**)。
     - **踢出 `nums[2]`(0)。** 终于踢掉一个坏蛋！`cnt0` 变回 2。`left` 变成 3。
  4. `cnt0` 是 2，不大于 `k` 了，停止循环。

  此时窗口变成了：`[0, 1, 1, 1, 0]` (下标 3 到 7)。

  当前窗口长度是：`7 - 3 + 1 = 5`。

  **关键点来了：**

  虽然现在的窗口长度只有 **5**，但是 `ans` 依然保持着 **7**。

  这就是你担心的“窗口外的部分”——刚才被踢出去的左边那部分，已经在第 7 步被 `ans` 永久记录下来了。

  ------

  #### 第三阶段：继续尝试

  `right` 继续走。

  | **步骤** | **right 指向的值** | **窗口内容**         | **cnt0** | **状态** | **计算长度** | **ans** |
  | -------- | ------------------ | -------------------- | -------- | -------- | ------------ | ------- |
  | 9        | `1`                | `[0, 1, 1, 1, 0, 1]` | 2        | OK       | 长度 6       | **7**   |

  第 9 步，虽然窗口又变长了一点（变成 6），但还是没有超过历史最高记录 7，所以 `ans` 还是 7。

  ### 总结这个例子的核心逻辑

  1. **ans 就像一个“记分牌”：** 它不关心现在的窗口有多惨（比如第 8 步缩水到了 5），它只关心“我这辈子见过的最长窗口是多少”。
  2. **窗口外的 1 去哪了？**
     - **左边的 1：** 在它们被迫离开窗口之前，它们曾经属于某个合法窗口，那个窗口的长度已经被记录在 `ans` 里了。
     - **右边的 1：** 还没进窗口，未来会算进去。

  所以，这段代码绝对不会漏掉任何一种可能得高分的情况！

### 总结

这段代码逻辑其实是：

> “我们要遍历每一个位置 `right`，计算**以这个 `right` 结尾**的最长有效子数组是多少。”

- 当 `right` 在第 2 位时，最长有效长度是 3，`ans` 记住了 3。
- 当 `right` 在第 5 位时，最长有效长度是 1，`ans` 比较 `max(3, 1)`，依然保留 3。

**结论：** 窗口外的部分，如果是**过去**的，已经被 `ans` 记录了；如果是**未来**的，迟早会被 `right` 扫到。所以不会漏掉。