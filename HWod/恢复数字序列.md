# 恢复数字序列

## 一、题目

对于一个连续正整数组成的序列，可以将其拼接成一个字符串四，再将字符串里的部分字符打乱顺序。

如序列89101112，拼接成的字符串为89101112，打乱一部分字符后得到90811211，原来的正整数10就被拆成了0和1。
现给定一个按如上规则得到的打乱字符的字符串，请将其还原成连续正整数序列，并输出序列中最小的数字。

输入描述:

> 输入一行，为打乱字符的字符串和正整数序列的长度，两者间用空格分隔，字符串长度Q不超过200，正整数不超过1000，保证输入可以还原成唯一序列。

输出描述:

> 输出一个数字，为序列中最小的数字。 

## 二、代码

**思路：**

代码不是将输入的一个个数字进行组装，而是不断猜想一些连续的数字，将这些数字拆解和输入的序列进行对比

```python
import sys

def get_digit_counts(n):
    """统计单个数字中各数位的频次"""
    counts = [0] * 10
    for char in str(n):
        counts[int(char)] += 1
    return counts

def solve():
    # 读取输入
    input_data = sys.stdin.read().split()
    if not input_data:
        return
    
    shuffled_str = input_data[0]
    k = int(input_data[1])
    
    # 1. 目标频次统计
    target_counts = [0] * 10
    for char in shuffled_str:
        target_counts[int(char)] += 1
    
    # 2. 初始化窗口（起始序列为 1 到 k）
    current_counts = [0] * 10
    for i in range(1, k + 1):
        for char in str(i):
            current_counts[int(char)] += 1
            
    # 3. 滑动窗口
    # 根据题目约束，正整数不超过 1000，我们枚举起始数字 s
    for s in range(1, 1001):
        # 检查当前窗口是否匹配
        if current_counts == target_counts:
            print(s)
            return
        
        # 窗口向右滑动：移出 s, 移入 s + k
        # 减去即将离开窗口的 s 的贡献
        for char in str(s):
            current_counts[int(char)] -= 1
        
        # 加上新进入窗口的 s + k 的贡献
        for char in str(s + k):
            current_counts[int(char)] += 1

if __name__ == "__main__":
    solve()
```

## 三、问答

1.统计数字频次为什么不能直接用Counter()呢?

这是一个非常好的问题！答案是：**完全可以使用 `collections.Counter`**，而且代码会写得更简洁、更 Pythonic。

但在算法竞赛或高性能要求的场景下，我们倾向于使用**固定长度数组（列表）**（即 `[0]*10`），主要有两个原因：**性能开销**和**“零值”陷阱**。

### 1. 最大的坑：“零值”导致的相等判断失败

这是用 `Counter` 做滑动窗口时最容易出的 Bug。

- **逻辑**：当一个数字移出窗口时，你会执行 `window_counts[x] -= 1`。
- **问题**：如果某个数字的频次减到了 `0`，`Counter` **不会自动删除这个 Key**，它会保留 `{'x': 0}`。
- **后果**：
  - 目标 Counter（没有这个数字）：`{'a': 1}`
  - 窗口 Counter（减到0后）：`{'a': 1, 'b': 0}`
  - **判断结果**：`Counter({'a': 1}) == Counter({'a': 1, 'b': 0})` 结果为 **False**。

如果你用 `Counter`，你必须在每次减法后手动清理：

```python
window_counts[out_digit] -= 1
if window_counts[out_digit] == 0:
    del window_counts[out_digit]  # 必须手动删除，否则和目标Counter匹配不上
```

而使用数组 `[0]*10`，位置永远固定，0 就是 0，对比时直接比较值，没有任何歧义。

### 2. 性能开销 (Overhead)

虽然在这个题目（数据量小）中感觉不到差异，但在处理大数据量时：

- **数组 (`list`)**：
  - **存取**：`counts[i]` 是基于内存地址偏移的直接访问，速度极快（$O(1)$）。
  - **创建**：分配一段连续内存，极快。
- **Counter (基于 `dict`)**：
  - **存取**：需要对 Key 进行**哈希运算 (Hashing)**，处理哈希冲突，然后查找，比数组慢。
  - **创建**：创建字典对象的开销比创建列表大得多。

### 3. 代码对比

如果你想用 `Counter` 实现滑动窗口，代码是这样的（注意 `del` 的部分）：

```python
from collections import Counter
import sys

def solve():
    # ... (读取输入代码略) ...
    shuffled_str = "19801211" # 示例
    k = 5
    
    # 1. 目标统计
    target_counts = Counter(shuffled_str)
    
    # 2. 初始窗口
    window_str = ""
    for i in range(1, k + 1):
        window_str += str(i)
    window_counts = Counter(window_str)
    
    for s in range(1, 1001):
        # 比较
        if window_counts == target_counts:
            print(s)
            return
            
        # 滑动窗口：移出 s
        for char in str(s):
            window_counts[char] -= 1
            if window_counts[char] == 0: # 【关键】：必须手动删除0值key
                del window_counts[char]
        
        # 滑动窗口：移入 s + k
        for char in str(s + k):
            window_counts[char] += 1
```

### 总结

- **可以用吗？** 可以。
- **推荐吗？**
  - **在工程代码/脚本中**：**推荐**。`Counter` 语义更清晰，可读性高。
  - **在算法题/高性能场景中**：**不推荐**。因为需要手动处理 `del` 逻辑（容易忘），且哈希表比数组慢。由于本题的字符集非常小（只有 0-9），用 `[0]*10` 是最完美的数据结构选择。