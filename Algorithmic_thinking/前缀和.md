# 前缀和

```python
def build_prefix_sum(arr):
    """构建前缀和数组"""
    prefix = [0]
    for num in arr:
        # -1表示列表最后一个
        prefix.append(prefix[-1] + num)
    return prefix

def query_sum(prefix, l, r):
    """查询区间和，l和r都是闭区间索引"""
    return prefix[r + 1] - prefix[l]
```

1. **初始状态**：

   python

   ```
   prefix = [0]  # prefix[-1] = 0
   ```

   

2. **第一次循环**（`num = 1`）：

   python

   ```
   # prefix[-1] 获取当前最后一个元素：0
   # 计算：0 + 1 = 1
   prefix.append(1)  # prefix 变成 [0, 1]
   ```

   

3. **第二次循环**（`num = 2`）：

   python

   ```
   # prefix[-1] 获取当前最后一个元素：1
   # 计算：1 + 2 = 3
   prefix.append(3)  # prefix 变成 [0, 1, 3]
   ```

   

4. **第三次循环**（`num = 3`）：

   python

   ```
   # prefix[-1] 获取当前最后一个元素：3
   # 计算：3 + 3 = 6
   prefix.append(6)  # prefix 变成 [0, 1, 3, 6]
   ```

   

5. **第四次循环**（`num = 4`）：

   python

   ```
   # prefix[-1] 获取当前最后一个元素：6
   # 计算：6 + 4 = 10
   prefix.append(10)  # prefix 变成 [0, 1, 3, 6, 10]
   ```



# 前缀和，前缀积

前缀和初始化为0，前缀积初始化为1

这两者的初始化值不同，背后的数学原理是**“单位元” (Identity Element)** 的概念：

### 1. 为什么前缀积初始化为 1？

- **数学原理：** 1 是乘法的“单位元”。
- **理由：** 任何数乘以 1 都等于它自己 ($x \times 1 = x$)。
- **如果初始化为 0 会怎样？** 灾难现场！因为 $x \times 0 = 0$。如果你的 `left` 数组一开始全是 0，那你后面不管乘什么数字，结果永远都是 0，整个算法就废了。

### 2. 为什么前缀和初始化为 0？

- **数学原理：** 0 是加法的“单位元”。
- **理由：** 任何数加上 0 都等于它自己 ($x + 0 = x$)。
- **如果初始化为 1 会怎样？** 结果会偏差。你的总和里会平白无故多出一个 1。