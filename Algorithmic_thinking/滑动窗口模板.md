# 滑动窗口

滑动窗口的核心思想就像一条**毛毛虫**：

1. **右指针（头）**先向前爬，吃进数据（扩大窗口）。
2. 当窗口里的东西**不符合条件**（比如吃撑了/超过限制）时，**左指针（尾巴）**向前收缩，吐出数据（缩小窗口）。
3. 在这个过程中不断记录“最佳状态”。

------

### 模板一：不定长滑动窗口（最常用）

**适用场景**：求满足条件的最长/最短子数组、最长无重复子串等。 **典型问题**：刚才那道“系统升级”题、LeetCode 3 (无重复字符的最长子串)、LeetCode 209 (长度最小的子数组)。

```python
def sliding_window_variable(nums):
    # 1. 初始化
    left = 0
    right = 0
    window_sum = 0  # 根据题目可能是 sum, count, 或 hashmap
    ans = 0         # 记录结果，求最小长度时初始化为 inf
    
    # 2. 右指针主动右移（扩大窗口）
    # 使用 enumerate 可以同时拿到下标和值，非常方便
    for right, x in enumerate(nums):
        # 【入窗】：把新元素加入窗口逻辑
        window_sum += x
        
        # 3. 左指针被动右移（缩小窗口）
        # 【判断条件】：只要当前窗口“不合法”（例如 sum > target），就一直缩
        while window_sum > target:  # 这里的条件根据题目改
            # 【出窗】：把左边元素移出窗口逻辑
            window_sum -= nums[left]
            left += 1  # 左指针前进
            
        # 4. 更新结果
        # 此时窗口一定是“合法”的，在这里记录结果
        # current_len = right - left + 1
        ans = max(ans, right - left + 1)
        
    return ans
```

#### 使用口诀：

> **进右，算右；不符，缩左；算左，更新。**

------

### 模板二：固定长度滑动窗口

**适用场景**：窗口大小 `k` 是固定的。 **典型问题**：LeetCode 643 (子数组最大平均数)、LeetCode 438 (找到字符串中所有字母异位词)。

```python
def sliding_window_fixed(nums, k):
    # 1. 初始化
    window_sum = 0
    ans = float('-inf') # 求最大值初始化为负无穷
    
    # 2. 右指针遍历
    for right, x in enumerate(nums):
        # 【入窗】
        window_sum += x
        
        # 3. 判断是否达到固定长度 k
        if right >= k:
            # 【出窗】：移除最左边那个已经过期的元素
            # 注意：移除的是 nums[right - k]
            window_sum -= nums[right - k]
            
        # 4. 更新结果
        # 只要窗口长度达到了 k (即 right >= k - 1)，就开始更新
        if right >= k - 1:
            ans = max(ans, window_sum)
            
    return ans
```

------

### 模板三：处理字符串（进阶版）

很多时候题目给的不是数字数组，而是字符串（例如“找包含ABC的最短子串”）。这时候需要用到**哈希表（字典）**。

建议使用 `collections.defaultdict` 或 `collections.Counter`，可以省去很多 `if key in dict` 的判断。

```python
from collections import defaultdict, Counter

def sliding_window_string(s):
    window = defaultdict(int) # 或者 window = {}
    left = 0
    ans = 0
    
    for right, char in enumerate(s):
        # 【入窗】
        window[char] += 1
        
        # 【收缩条件】：例如“出现了重复字符”
        while window[char] > 1:
            # 【出窗】
            left_char = s[left]
            window[left_char] -= 1
            left += 1
            
        # 【更新结果】
        ans = max(ans, right - left + 1)
        
    return ans
```

### 总结

你做题时，只需要问自己三个问题，就能套用上面的模板：

1. **入窗逻辑**是什么？（加法？哈希表计数？）
2. **出窗条件**（`while` 里的判断）是什么？（和大于 N？出现了重复字？）
3. **我们要找什么**？（最长 `max` 还是最短 `min`？）