# python中的四种基本数据结构

## 基本概念：

### 1. 列表 (List) `[ ]` —— **你的草稿纸/记事本**

- **特点：** 最常用，最灵活。
- **有序吗？** 有序（你写在第一行就是第一行）。
- **能改吗？** **可变 (Mutable)**。写错了可以擦掉重写，可以随时撕掉一页（删除），也可以随时插入一行。
- **能重复吗？** 能（你可以写两遍“我要去华为”）。
- **底层：** 就是刚才说的“搬砖”数组，连续内存。
- **场景：** 存一堆数据，后面还要遍历、修改、排序。

### 2. 元组 (Tuple) `( )` —— **塑封的证书/合同，不会变**

- **特点：** 安全，定死的数据。
- **有序吗？** 有序。
- **能改吗？** **不可变 (Immutable)**。一旦定义好（塑封了），就不能改字、不能删字、不能加字。想改？只能把旧的撕了，重新打印一张新的。
- **能重复吗？** 能。
- **底层：** 因为不可变，所以它比列表占用的内存更小，更轻量。
- **场景：** 这里的配置参数（Config）、函数返回的多个值、或者用来当字典的 Key（因为它是定死的，不会变）。

### 3. 集合 (Set) `{ }` —— **去重的点名册**

- **特点：** 这是一个**只有名字，没有顺序**的名单。
- **有序吗？** **无序**。你把 'a', 'b', 'c' 放进去，打印出来可能是 'c', 'a', 'b'。
- **能改吗？** 可变（可以加人，踢人），但不能“修改”某个人（不能说把第2个人改名，因为根本就没有“第2个”这种概念）。
- **能重复吗？** **绝对不能**。这就是你在 LeetCode 里用它来做滑动窗口判重的原因。
- **底层：** **哈希表 (Hash Table)**。查找速度是神速 $O(1)$。
- **场景：** 去重、求交集（A和B都有谁）、求差集、快速判断“某人在不在”。

### 4. 字典 (Dictionary) `{key: value}` —— **带索引的储物柜**

- **特点：** 也是用大括号 `{}`，但它是成对出现的。
- **结构：** 钥匙 (Key) : 物品 (Value)。
- **有序吗？** (Python 3.7+ 之后是按插入顺序显示的，但逻辑上我们仍把它看作基于 Key 查找)。
- **能改吗？** 可变。可以换锁，也可以换柜子里的东西。
- **能重复吗？** **Key 不能重复**（一个柜号只能对应一个柜子），但 **Value 可以重复**（不同的柜子里可以放一样的书）。
- **底层：** 和 Set 一样，也是 **哈希表**。通过 Key 找 Value 也是 $O(1)$。
- **场景：** 存用户信息 `{ "name": "Gemini", "age": 1, "job": "AI" }`。

------

### ⚡ 一张表搞定面试（建议截图保存）

| **数据结构**           | **符号**     | **有序?** | **可修改?** | **允许重复?** | **查找速度**  | **核心用途**                   |
| ---------------------- | ------------ | --------- | ----------- | ------------- | ------------- | ------------------------------ |
| **列表 List**          | `[1, 2]`     | ✅ 是      | ✅ 是        | ✅ 是          | 慢 $O(n)$     | 存数据，排序，也就是大多数情况 |
| **元组 Tuple**         | `(1, 2)`     | ✅ 是      | ❌ **否**    | ✅ 是          | 慢 $O(n)$     | 数据保护，作为字典的 Key       |
| **集合 Set（哈希表）** | `{1, 2}`     | ❌ 否      | ✅ 是        | ❌ **否**      | **快 $O(1)$** | **去重**，快速查找 (in)        |
| **字典 Dict**          | `{'k': 'v'}` | ✅*        | ✅ 是        | ❌ (Key不可)   | **快 $O(1)$** | 键值对映射，数据库查询结果     |

------

### 🎤 面试高频问题（华为 OD 可能会问）

**Q1: 列表 (List) 和 元组 (Tuple) 有什么区别？**

> **答：**
>
> 1. **语法不同：** 列表用 `[]`，元组用 `()`。
> 2. **可变性不同：** 列表可变，元组不可变（一旦创建不能修改）。
> 3. **用途不同：** 列表用于存储动态变化的数据；元组用于存储不希望被修改的数据，比如配置信息，而且元组可以作为字典的 Key，列表不行。

**Q2: 为什么要用 Set 而不用 List 来查找数据？**

> **答：**
>
> （结合你刚才的 LeetCode 题）
>
> 因为 List 的底层是数组，查找元素需要从头遍历到尾，时间复杂度是 $O(n)$。
>
> 而 **Set 的底层是哈希表，它可以通过计算哈希值直接定位内存地址**，时间复杂度是 $O(1)$。数据量越大，差距越明显。

**Q3: 如何去除列表中的重复元素？**

> **答：** 最快的方法是转成集合再转回来：`list(set(my_list))`。（注：但这会打乱原来的顺序）





```python
# 1. 列表：随意的
my_list = [1, 2, 2, 3]
my_list[0] = 100  # 没问题，改了
print(f"List: {my_list}") 

# 2. 元组：倔强的
my_tuple = (1, 2, 2, 3)
try:
    my_tuple[0] = 100 # 这里会报错！
except TypeError as e:
    print(f"Tuple Error: {e}")

# 3. 集合：洁癖的
my_set = {1, 2, 2, 3} 
print(f"Set: {my_set}") # 你会发现 2 只剩下一个了，去重了

# 4. 字典：精明的
my_dict = {"name": "User", "goal": "Huawei OD"}
print(my_dict["goal"]) # 瞬间查找到
```



## **基本操作：**

#### 🟢 1. 列表 List `[]` —— 你的书包（啥都能装，随时取拿）相当于数组

列表是最常用的，操作也最丰富。

```python
# --- 创建 ---
my_list = ["a", "b", "c"]

# --- 增 (Insert) ---
my_list.append("d")      # 放到最后面（最常用！） -> ['a', 'b', 'c', 'd']
my_list.insert(1, "x")   # 插队到索引1的位置 -> ['a', 'x', 'b', 'c', 'd']

# --- 删 (Delete) ---
my_list.pop()            # 弹出最后一个 -> 删掉 'd'
my_list.pop(0)           # 弹出第0个 -> 删掉 'a' (注意：这会导致后面元素前移，O(N)慢！)
my_list.remove("b")      # 按内容删，删掉第一个遇到的 "b"

# --- 查 (Find) ---
item = my_list[0]        # 按索引查 -> "x"
if "c" in my_list:       # 判断有没有（慢，O(N)）
    print("Found it")

# --- 改 (Update) ---
my_list[0] = "new_val"   # 直接修改
```



#### 🔴 2. 元组 Tuple `()` —— 密封的档案袋（只能看，不能改）

记住一点：**元组没有“增删改”的操作！** 只有“查”。

```python
# --- 创建 ---
my_tuple = (10, 20, 30)

# --- 增/删/改 ---
# ❌ 全部报错！AttributeError
# my_tuple.append(40)  -> 报错
# my_tuple[0] = 5      -> 报错

# --- 查 (Find) ---
item = my_tuple[1]       # 按索引查 -> 20
index = my_tuple.index(30) # 查某个值在哪 -> 2
count = my_tuple.count(20) # 查某个值出现了几次
```



#### 🔵 3. 集合 Set `{}` —— 只有名字的名单（去重、快速）

它的核心功能是**去重**和**判断是否存在**。

```python
# --- 创建 ---
my_set = {1, 2, 3}

# --- 增 (Insert) ---
my_set.add(4)            # 加一个 -> {1, 2, 3, 4}
my_set.add(2)            # 加重复的？没反应，也不会报错 -> {1, 2, 3, 4}

# --- 删 (Delete) ---
my_set.remove(1)         # 删掉 1。如果 1 不在里面，会报错！
my_set.discard(99)       # 💡 推荐：尝试删掉 99，如果不在也不报错（安全删除）

# --- 查 (Find) ---
# ❌ 集合没有索引！不能写 my_set[0]
if 2 in my_set:          # 核心功能！神速 O(1)
    print("在里面")
```



#### 🟡 4. 字典 Dict `{k:v}` —— 超市储物柜（凭票取物）

面试官最爱问这个，尤其是 `get` 方法。

```python
# --- 创建 ---
my_dict = {"name": "Gemini", "age": 1}

# --- 增 / 改 (Update) ---
# 逻辑一样：如果有这个 Key 就修改，没有就新增
my_dict["job"] = "AI"    # 新增 -> {'name': 'Gemini', 'age': 1, 'job': 'AI'}
my_dict["age"] = 2       # 修改 -> age 变成 2

# --- 删 (Delete) ---
my_dict.pop("age")       # 删掉 key 为 "age" 的那对数据
del my_dict["name"]      # 另一种删法

# --- 查 (Find) ---
print(my_dict["job"])    # -> "AI"
# ⚠️ 危险写法：如果查一个不存在的 key，比如 my_dict["salary"]，程序会直接报错崩溃！

# ✅ 安全写法 (面试加分点)：
print(my_dict.get("salary"))      # 如果没有，返回 None，程序不崩
print(my_dict.get("salary", 0))   # 如果没有，返回默认值 0
```





