# SQL基础语法

## 1. AS

### 1. AS 的用法：起“外号”（别名）

`AS` 关键字用于给**表**或者**列**起一个临时名字（Alias），让代码更简洁或解决冲突。

- **给表起别名（关键用法）**： 当你需要多次引用同一张表（如自连接）时，必须用 `AS` 区分。

  - *示例*：`Employee AS e` 表示在接下来的查询中，我把 `Employee` 表简称为 `e` 。
  - *作用*：如果不给表起别名，数据库就不知道你说的 `salary` 是员工的还是经理的。

- **给列起别名**： 改变输出结果显示的表头名称。

  - *示例*：`SELECT name AS Employee` 会让查询出来的结果表头显示为 "Employee" 而不是原来的 "name" 。

  ```sql
  SELECT
      e.name AS Employee
  FROM
      Employee AS e
  JOIN
      Employee AS m ON e.managerId = m.id
  WHERE
      e.salary > m.salary;
  ```

  

## 2. JOIN

`JOIN` 用于根据两个表之间共同的列，将它们的行组合在一起。同一张表也可以JOIN

https://leetcode.cn/problems/employees-earning-more-than-their-managers/description/?envType=problem-list-v2&envId=shujuku-db1-sql-i

- **语法结构**： `FROM 表1 JOIN 表2 ON 关联条件`
- **最常用的 JOIN（等值连接/内连接）**： 只有当 `ON` 后面的条件成立时，两张表的行才会拼成一行。
  - *在你的题目中*：`Employee AS e JOIN Employee AS m ON e.managerId = m.id` 。
  - **逻辑拆解**：
    1. 左边是**员工表 (e)**，右边是**经理表 (m)**。
    2. `ON e.managerId = m.id` 的意思是：只有当“员工的经理ID”等于“经理的个人ID”时，才把这两行拼在一起。
    3. 拼完之后，这一行数据里既有员工的工资（`e.salary`），也有他经理的工资（`m.salary`），你就可以直接对比了 。



## 3. 不等于 <> 和！=

## 4. 判断等于：一个=

```sql
SELECT *
FROM cinema AS c
WHERE c.id % 2 = 1 and c.description != 'boring'
ORDER BY c.rating DESC
```



## 5. JOIN连接进阶

如果使用 `INNER JOIN`（等值连接）：只有两张表都有的数据才会显示。在这个例子中，Allen 就会因为在地址表里没数据而被“弄丢”了。

如果使用 `LEFT JOIN`（左外连接）：会保留左表（Person表）的所有人，如果右表（Address表）没匹配上，会自动填入 `Null`。这正是题目要求的。

> 表: `Person`
>
> ```
> +-------------+---------+
> | 列名         | 类型     |
> +-------------+---------+
> | PersonId    | int     |
> | FirstName   | varchar |
> | LastName    | varchar |
> +-------------+---------+
> personId 是该表的主键（具有唯一值的列）。
> 该表包含一些人的 ID 和他们的姓和名的信息。
> ```
>
> 表: `Address`
>
> ```
> +-------------+---------+
> | 列名         | 类型    |
> +-------------+---------+
> | AddressId   | int     |
> | PersonId    | int     |
> | City        | varchar |
> | State       | varchar |
> +-------------+---------+
> addressId 是该表的主键（具有唯一值的列）。
> 该表的每一行都包含一个 ID = PersonId 的人的城市和州的信息。
> ```
>
> 编写解决方案，报告 `Person` 表中每个人的姓、名、城市和州。如果 `personId` 的地址不在 `Address` 表中，则报告为 `null` 。
>
> 以 **任意顺序** 返回结果表。
>
> 结果格式如下所示。
>
> **示例 1:**
>
> ```
> 输入: 
> Person表:
> +----------+----------+-----------+
> | personId | lastName | firstName |
> +----------+----------+-----------+
> | 1        | Wang     | Allen     |
> | 2        | Alice    | Bob       |
> +----------+----------+-----------+
> Address表:
> +-----------+----------+---------------+------------+
> | addressId | personId | city          | state      |
> +-----------+----------+---------------+------------+
> | 1         | 2        | New York City | New York   |
> | 2         | 3        | Leetcode      | California |
> +-----------+----------+---------------+------------+
> 输出: 
> +-----------+----------+---------------+----------+
> | firstName | lastName | city          | state    |
> +-----------+----------+---------------+----------+
> | Allen     | Wang     | Null          | Null     |
> | Bob       | Alice    | New York City | New York |
> +-----------+----------+---------------+----------+
> 解释: 
> 地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。
> addressId = 1 包含了 personId = 2 的地址信息。
> ```



```sql
SELECT 
    p.FirstName, 
    p.LastName, 
    a.City, 
    a.State
FROM Person AS p
LEFT JOIN Address AS a ON p.PersonId = a.PersonId;
```



## 6. null的判断

> IS NULL





## 7.聚合GROUP BY

> 表: `Orders`
>
> ```
> +-----------------+----------+
> | Column Name     | Type     |
> +-----------------+----------+
> | order_number    | int      |
> | customer_number | int      |
> +-----------------+----------+
> 在 SQL 中，Order_number是该表的主键。
> 此表包含关于订单ID和客户ID的信息。
> ```
>
> 
>
> 查找下了 **最多订单** 的客户的 `customer_number` 。
>
> 测试用例生成后， **恰好有一个客户** 比任何其他客户下了更多的订单。
>
> 查询结果格式如下所示。
>
>  
>
> **示例 1:**
>
> ```SQL
> 输入: 
> Orders 表:
> +--------------+-----------------+
> | order_number | customer_number |
> +--------------+-----------------+
> | 1            | 1               |
> | 2            | 2               |
> | 3            | 3               |
> | 4            | 3               |
> +--------------+-----------------+
> 输出: 
> +-----------------+
> | customer_number |
> +-----------------+
> | 3               |
> +-----------------+
> 解释: 
> customer_number 为 '3' 的顾客有两个订单，比顾客 '1' 或者 '2' 都要多，因为他们只有一个订单。
> 所以结果是该顾客的 customer_number ，也就是 3 。
> ```
>
> **进阶：** 如果有多位顾客订单数并列最多，你能找到他们所有的 `customer_number` 吗？



```sql
SELECT customer_number
FROM Orders AS o
GROUP BY o.customer_number
ORDER BY COUNT(order_number) DESC
LIMIT 1
```





## 8. WHERE` vs `HAVING

**`WHERE` (先执行)**：是在数据**分组前**进行的筛选。它看不见 `COUNT`、`SUM` 这种聚合后的结果。

**`HAVING` (后执行)**：是在数据**分组后**进行的筛选。它专门用来过滤那些已经统计好的数字。



## 9. DISTINCT去重

### 1. 场景模拟

假设你的 RAG 医疗大模型系统中有一张**测试记录表** `Model_Tests`，记录了模型对不同问题的回答情况。由于系统可能多次测试同一个问题，表中存在重复的 `question_id`。

**表：`Model_Tests`** 

```plaintext
+----+-------------+----------------+------------+
| id | question_id | answer_quality | test_date  |
+----+-------------+----------------+------------+
| 1  | 101         | Good           | 2026-01-01 |
| 2  | 102         | Fair           | 2026-01-01 |
| 3  | 101         | Good           | 2026-01-02 |
| 4  | 103         | Poor           | 2026-01-02 |
+----+-------------+----------------+------------+
```

**任务**：你需要统计该模型总共测试了**多少个独立（不重复）**的问题。

------

### 2. 解决方案

#### 方法 A：查询所有不重复的问题 ID

如果你只是想列出这些 ID：

```sql
SELECT DISTINCT question_id
FROM Model_Tests;
```

#### 方法 B：统计不重复问题的总数（面试高频）

如果你需要返回一个具体的数字（常用于汇报测试覆盖率）：

```sql
SELECT COUNT(DISTINCT question_id) AS total_unique_questions
FROM Model_Tests;
```

------

### 3. `DISTINCT` 的核心语法规则

1. **位置**：`DISTINCT` 必须放在 `SELECT` 关键字的紧后面，不能放在中间字段 。
2. **多列去重**：如果你写 `SELECT DISTINCT col1, col2`，数据库会根据这两列的**组合**来去重。只有当两行数据的 `col1` 和 `col2` **完全一样**时才会被去重。
3. **效率注意**：在处理像元宝这种亿级数据量时，`DISTINCT` 会触发全表扫描和排序，性能开销较大 。

------

### 4. 结合你简历的面试“拔高”回答

既然你简历里提到“基于 Python 编写自动化测试脚本，对模型输出进行一致性测试” ，面试官如果问你 `DISTINCT`，你可以这样反撩：

> **面试官**：你会用 `DISTINCT` 吗？
>
> **你**：会。在之前的 RAG 医疗模型项目中，我会用 `COUNT(DISTINCT question_id)` 来计算**测试用例的覆盖率**，确保我们的 1000 条测试集在多次自动化运行中没有重复统计 。
>
> 另外，在做**结果验证**时，如果模型对同一个 Prompt 输出了多个不同的结果（幻觉表现），我会用 `DISTINCT` 配合 `GROUP BY` 来定位哪些问题导致了模型输出的不稳定，从而辅助算法同事定位模型波动问题 。